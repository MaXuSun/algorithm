# 随便取个标题吧，反正也没人看得见
这个库的功能：
* 主要记录自己刷`leetcode`的过程
* 对刷过的`leetcode`题目分类。
* 总结刷题中的算法
* 总结算题中的错误

# 进度
刚开始做了leetcode中前30道题目，发现前30效率很低，接下来打算换刷题方式，先列出来每个题型考查的知识点。

# 知识点
## 1. 链表
|知识点|题目|必须掌握|
|:--:|:--:|:--:|
|反转链表|92，206|头插、迭代、递归|
|回文链表|234|反转后半段、递归|
|链表中环的入口节点|142|快慢指针先相遇，慢指针重置到头再相遇|
|判断链表中是否有环|141|快慢指针相遇的地方为环，快指针遇到null则无环|
|删除链表中倒数第K个节点|19|快慢指针，快先走|
|链表中的节点每K个一组反转|25|迭代、递归|
|合并有序链表|21，23|优先队列、归并|
|删除有序链表中重复出现的元素|83|迭代、递归、尾插|
|环形链表的约瑟夫问题|||
|重排链表|143|反转+中点+归并，这个题目算是一个综合题，所以考的比较多|
|必做题目|23，142，19，92，25，234||

## 2. 树

|知识点|题目|必须掌握|
|:--:|:--:|:--:|
|中序遍历|94|递归、Morris、栈|
|前序遍历|144|递归、Morris、栈|
|层序遍历|102|BFS|
|前+中构建树|105|递归、栈|
|后+中构建树|106|递归、栈|
|前+后构建树|889|递归|
|序列化|297|含有**空指针**的前序或后序遍历结果，单个就能序列化，反序列化和序列化的过程相似|
|二叉搜索树遍历||**1.中序遍历是升序序列**<br>**2.在节点添加一个size记录以该节点为根的树的节点数，可以据此判断该节点在升序序列中排第几**|
|二叉搜索树判定|98，1373|递归|
|二叉搜索树插入|701|递归，迭代|
|二叉搜索树删除|450|递归、如何找前驱节点和后继节点，二叉树搜索树删除的3种情况|
|二叉树可能性的穷举|95，96|96是DP，95是穷举，正是薄弱的地方|


* 使用Morris的题目：538，94，144
* 二叉搜索树的定义，一定要记全：**如果左子树不为null，根节点的值>左子树的最大值，如果右子树不为null，根节点的值<右子树的最小值**
* 二叉搜索树删除的三种情况：1. 只有左子树或者右子树  2. 当前节点为叶子节点   3. 当前节点同时有左子树和右子树（这种情况要找前驱或者后继）
* 好文章
  * [114题解](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/)
* 如何将树的递归代码转为迭代代码(统一结构)[labuladong](https://labuladong.gitee.io/algo/2/18/33/)

```python
1. 先看下递归的树遍历代码

def traverse(root):
    if not root:
        return None

    """①.这一块放前序遍历代码"""
    traverse(root.left)
    """②.这一块放中序遍历代码"""
    traverse(root.right)
    """③.这一块放后序遍历代码"""

2. 我们知道所有的递归算法都可以借用栈改成迭代算法，我们看下这个递归过程的特点
    (1). 从根节点开始，一直往栈中压入now.left，直到left为None才停止
    (2). 从栈顶弹出节点top，拿出top.right节点 (top节点的left一定是None或者遍历过的，否则栈顶绝对不是这个节点)
    (3). 从上面的top.right节点开始，一直往栈中压入left，直到left为None才停止
    (4). 重复 (2),(3) 直到栈为空

根据上述分析，我们写出迭代的代码：

def pushleft(stack,root):
    while root:
        stack.push(root)
        root = root.left

def traverse(root):
    stack = collections.dequeue
    pushleft(stack,root)            # 第(1)步
    while not stack.empty():
        top = stack.pop()           # 重复第 (2) 步
        pushleft(stack,top)         # 重复第 (3) 步

3. 将递归改写成上面的迭代后，怎么确定前、中、后序的位置？
    (1). 前序一定在压栈动作的前一刻发生
    (2). 中序一定在左子树遍历完，右子树没遍历的时刻发生
    (3). 后序一定在左右子树都遍历完的时刻发生
根据上面(1)、(2)、(3)三点，我们再次改写上面的pushleft和traverse代码

def pushleft(stack,root):
    while root:
        """①. 这里是前序代码的位置"""
        stack.push(root)
        root = root.left

def traverse(root):
    stack = collections.dequeue()
    pushleft(root)
    while not stack.empty():
        p = stack[0]

        if p的左子树遍历完了，右子树没有遍历:
            """②.中序遍历的位置"""
            pushleft(stack,p.right)
        
        if p的右子树遍历完了:
            """③.后序遍历的位置"""
            stack.pop()

4. 那么我们怎么记录左子树和右子树有没有遍历完呢？我们使用一个visited来记录，记录之后改写traverse函数

这里我尝试去解释一下为什么这样加个visited就可以：
1. 在解释之前，我们先说一个规律：在压入的栈中，如果记top=stack[0],那么stack[1]一定是top的父节点
2. 首先对于之前的写法，我们一直压入左子节点，当无法压入的时候，当前栈顶元素为top，我们把top弹出，把top.right压入。而现在我们不把top弹出，直接把top.right压入，这样的话，从top开始的位置到stack的头部，一定是top子树上的节点。那这样的话，根据1的规律，每次退栈一定会出现 top.right --> top和top.left --> top的退栈顺序。
3. 下面我们注意visited=stack.pop()这行代码，注意到这行代码执行后有两种情况:
    (1). 直接退出while，这种情况是遍历完了，我们不考虑
    (2). 紧跟着执行p = stack[0]这句代码。根据1的规律，我们知道visited一定是p的子节点。这样的话就有下面两种情况：
        ①. visited==p.left，那说明我们left子树已经遍历完了(因为我们在回退阶段)，我们跳入中序遍历的代码块里。
        ②. visited==p.right，那说明我们left子树和right子树都遍历完了(因为我们在回退阶段并且左子树已经比右子树先遍历完)
4. 至此分析完毕。

def traverse(root):
    stack = collections.dequeue()
    pushleft(root)
    while not stack.empty():
        p = stack[0]

        if (p.left is None or p.left == visited) and p.right != visited:
            """②.中序遍历的位置"""
            pushleft(stack,p.right)
        
        if p.right is None or p.right == visited:
            """③.后序遍历的位置"""
            visited = stack.pop()
```

## 3. 图

|知识点|题目|必须掌握|
|:--:|:--:|:--:|
|拓扑排序|210|DFS和BFS|
|二分图|785|DFS和BFS|
|并查集|323,130,990|并查集的几个函数：union、connected、count、findparent|

* 当图有环时，需要一个visited记录遍历过的点
* 图中的onPath数组操作和回溯算法中的操作区别：图中在for外，回溯算法在for内。主要区别就是，for内会**唯独缺少整棵树根的进入和离开**
* 对于二分图：遍历节点要判断临近节点是否visited，如果临近节点visited就判断临近节点和当前节点颜色是否相同，否则就上色
* 并查集解决问题的思路：**适当增加虚拟节点，想办法让元素分门别类，建立动态连通关系**
```
并查集代码：
class UnionFind:
    def __init__(self,n):
        self.parent = [i for i in range(n)]
        self.size = [1] * n
        self.count = n

    def find(self,x):
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    
    def merge(self,x,y):
        rootx = self.find(x)
        rooty = self.find(y)
        if self.size[rootx] > self.size[rooty]:
            self.parent[rooty] = rootx
            self.size[rootx] += self.size[rooty]
        else:
            self.parent[rootx] = rooty
            self.size[rooty] += self.size[rootx]
        self.count -= 1
    
    def isunion(self,x,y):
        if self.find(x) == self.find(y):
            return True
        else:
            return False
```
* Krustral 算法：先根据边的升序排序，然后使用并查集依次合并不会使已选节点成环的边，最后判断并查集连通量是否符合条件(注意0和节点编号是否对应)
* Prime算法(会Krustral算法就行)：
  * 假设图有{A,B,C,D,E,F}这6个节点，初始化两个集合set1= {A}, set2={B,C,D,E,F}
  * 找到set1与set2的横切边，选择最小的边(这里假设为AB)，那么更新set1 = {A,B}, set2 = {C,D,E,F}
  * 重复上述步骤直到set2={}
  * 注意：{A,B}与{C,D,E,F}的横切边 = {A} 与 {B,C,D,E,F}的横切边 + {B} 与 {C,D,E,F}的横切边 - AB边
* Dijkstra算法([这里就使用labuladong文章里的记法吧](https://labuladong.gitee.io/algo/2/19/43/))：
  * BFS遍历，
    * 需要一个数组diststart[0,inf,inf,....]用于记录最终结果
    * 需要一个结构`(节点，距离)`存储每个节点i到start的临时距离temp_i
  * 核心思想：每次遍历到队头节点A时：
    1.  临时距离temp_A > diststart[A]: 不做操作
    2.  临时距离temp_A < diststart[A]: 则遍历A的所有临接节点B
        1.  if temp_A + AB < diststart[B]: ①.更新diststart[B] = temp_A + AB ②. 更新 temp_B = diststart[B] ③. 将B添加如队列queue中
        2. else: 不做操作
```
import queue
# 初始化临接表的图
graph = [[] for _ in range(n+1)]
for edge in edges:
    frm,to,w = edge
    graph[frm].append((to,w))

# 初始化距离
diststart = [float('inf')]*(n+1)
diststart[k] = 0
# 初始化优先队列
q = queue.PriorityQueue()
q.put((diststart[k],k))

while not q.empty():
    u_d,u = q.get()            # 获取队头节点
    
    if u_d > diststart[u]:
        continue
    
    for v,uv in graph[u]:
        v_d = diststart[u] + uv
        if v_d < diststart[v]:
            diststart[v] = v_d
            q.put((v_d,v))

res = max(diststart[1:])
return -1 if res == float('inf') else res

```
## 4. 动态规划
### 4.1  DP入门

| 天数  | 题目                                                                       | 完成度 | 日期  |             问题              |
| :---: | :------------------------------------------------------------------------- | :----: | :---: | :---------------------------: |
|   1   | 509: 斐波拉契数<br>1137: 第N个泰波那契数                                   |  完成  | 1.13  |             null              |
|   2   | 70: 爬楼梯<br>746: 使用最小花费爬楼梯                                      |  完成  | 1.13  |             null              |
|   3   | 198: 打家劫舍<br> 213: 打家劫舍2 <br>740: 删除并获得点数                   |  完成  | 1.13  |        740需要转换思路        |
|   4   | 55: 跳跃游戏<br>45: 跳跃游戏2                                              |  完成  | 1.13  |         python 45超时         |
|   5   | 53：最大子数组和<br>918：环形子数组的最大和                                |  完成  | 1.13  |        918需要转换思路        |
|   6   | 152: 乘积最大子数组<br>1567 乘积为正数的最长子数组                         |  完成  | 1.14  |   152,1567开拓思路,可以再做   |
|   7   | 1014: 最佳观光组合<br>121: 买卖股票的最佳时机 <br>122: 买卖股票的最佳时机2 |  完成  | 1.14  |                               |
|   8   | 309: 最佳买卖股票时机含冷冻期<br>714: 买卖股票的最佳时机含手续费           |  完成  | 1.15  | 309是一个新的dp套路，可以再做 |
|   9   | 139：单词划分<br>42: 接雨水                                                |  完成  | 1.15  |       139是个新的DP问题       |
|  10   | 413：等差数列划分<br>91：解码方法                                          |  完成  | 1.16  |       91是个新的DP问题        |
|  11   | 264: 丑数2<br>96: 不同的二叉搜索树                                         |    完成    | 1.16  |    264从前往后推，值得思考，96也可以再做    |
|  12   | 118: 杨辉三角<br>119: 杨辉三角2                                                 | 完成 | 1.16    |  |
|  13   | 931: 下降路径最小和<br>120: 三角形最小路径和                               | 完成 | 1.16  | 新的DP，做931就行  |
|  14   | 1314: 矩阵区域和<br>304：二维区域和检索-矩阵不可变                         |    重复    | 1.17  |   二维前缀和+DP, 做1314就行 |
|  15   | 62：不同路径<br>63：不同路径2                                              | 完成 | 1.17  | 比较简单，练63就够了|
|  16   | 64：最小路径和<br>221：最大正方形                                          | 完成  | 1.17  | 221可以再做一遍 |
|  17   | 5：最长回文子串<br>516：最长回文子序列                                     | 完成 | 1.17  | 516有点意思，可以再做|
|  18   | 300：最长递增子序列<br>376: 摆动序列                                    | 完成 | 1.18  | 300经典题目,37可以和day6的两道题一起看|
|  19   | 392：判断子序列<br>1143: 最长公共子序列 <br>72: 编辑距离   | 完成  | 1.18  | 72比较难可以再做，392是个新DP|
|  20   | 322: 零钱兑换<br>518：零钱兑换2  | 完成  | 1.18  |  新DP题型，不熟悉，可以再琢磨 |
|  21   | 377：组合总和4<br>343: 整数拆分 <br>279: 完全平方数  | 完成 | 1.18  |518和377可以放在一起看，279是个背包问题，343这个题可以再做  |

### 4.2 DP基础

| 天数  | 题目 |难度| 题型|完成度 | 日期  |  问题   |  
| :---: | :--- | :----:|:----:|:---: | :---: | :---: |
|01|509：斐波拉契数 <br> 70: 爬楼梯 <br> 746：使用最小花费爬楼梯|简单<br>简单<br>简单|基础|||
|02|53：最大数组和<br> 198：打家劫舍 <br> 213：打家劫舍2|简单<br>中等<br>中等|线性|||
|03|256：粉刷房子<br>265：粉刷房子2<br> 121：买卖股票的最佳时机|中等<br>困难<br>简单|线性|||
|04|714：买卖股票的最佳时机含手续费<br> 309：最佳买卖股票时机含冷冻期 <br> 152: 乘积最大子数组| 中等<br>中等<br>中等|线性|||
|05|487：最大连续1的个数 II <br> 376: 摆动序列 | 中等<br>中等|线性|||
|06|1746：经过一次操作后的最大子数组和 <br> 1230：投掷硬币 |中等<br>中等|线性|||
|07|1143：最长公共子序列 <br> 1035：不相交的线 | 中等<br>中等|字符串,最长递增，最长公共|||
|08| 712：两个字符串的最小ASCII删除和 <br> 300: 最长递增子序列 | 中等<br>中等|字符串,最长递增，最长公共|||
|09|673：最长递增子序列的个数 <br> 1048: 最长字符串链 | 中等 <br> 中等 <br> 中等 |字符串,最长递增，最长公共|||
|10|646：最长数对链 <br> 368：最大整除子集 | 中等 <br> 中等| 字符串,最长递增，最长公共|||
|11|647：回文子串 <br> 5：最长回文子串 | 中等 <br> 中等 |字符串,最长递增，最长公共|||
|12|1055：形成字符串的最短路径 <br> 516：最长回文子序列 | 中等<br>中等|字符串,最长递增，最长公共|||
|13|64：最小路径和 <br> 562: 矩阵中最长的连续1线段 <br> 1182：与目标颜色间的最短距离|中等<br>中等<br>中等|最小(最大)路径目标|||
|14| 343：整数拆分 <br> 238：除自身以为数组的乘积|中等 <br> 中等 | 经典|||
|15| 139: 单词拆分 <br> 254：因子的组合 <br> 329：矩阵中的最长递增路径| 中等<br>中等<br>困难|记忆化|||
|16| 62：不同路径 <br> 63：不同路径2 | 中等 <br> 中等| 计数|||
|17|576：世界的路径数 <br> 650：只有两个键的键盘 <br> 361：轰炸敌人 |中等<br>中等<br>中等|计数|||
|18|96：不同的二叉搜索树 <br> 1130：叶值的最小代价生成树 | 中等 <br> 中等| 合并间隔|||
|19|322：零钱兑换 <br> 518：零钱兑换2 | 中等 <br> 中等 |硬币兑换/组合和|||
|20|39：组合总和 <br> 279：完全平方数| 中等 <br>中等|硬币兑换/组合和|||
|21|416：分割等和子集 <br> 494：目标和 | 中等 <br> 中等 | 背包问题|
|相比入门的新题|256，265，487，1746，|1230，1035，712，673，|1048，646，368，647，|1055，562，1182，238，|254，329，576，650，|361，1130，416，494|

### 4.3 DP进阶(只把新题整理出来)

| 天数  | 题目 |难度| 题型|完成度 | 日期  |  问题   |  
| :---: | :--- | :----:|:----:|:---: | :---: | :---: |
|01| 1884：鸡蛋掉落-两枚鸡蛋<br> 887：鸡蛋掉落|中等<br>困难|经典|||
|02| 188：买卖股票的最佳时机4|困难|线性|||
|03|1751：最多可以参加的会议数目<br>1235：规划兼职工作|困难<br>困难|线性|||
|04|1259：不相交的握手<br>1478：安排邮筒|困难<br>困难|线性|||
|05|115：不同的子序列<br>435：无重叠区间|困难<br>中等|字符串，最长递增，最长公共|||
|06|452：用最小数量的箭引爆气球<br>72：编辑距离|困难<br>困难|字符串，最长递增，最长公共|||
|07|1682：最长回文子序列2<br>1062：最长重复子串|中等<br>中等|字符串，最长递增，最长公共|||
|08|1092：最短公共超序列<br>10：正则表达式匹配|困难<br>困难|字符串，最长递增，最长公共|||
|09|1216：验证回文字符3<br>727：最小窗口子序列|困难<br>困难|字符串，最长递增，最长公共|||
|10|741：摘樱桃<br>1463：摘樱桃2|困难<br>困难|到达目标的|||
|11|140：单词拆分2<br>351：安卓手势解锁|困难<br>中等|记忆化|||
|12|688："马"在棋盘上的概率<br>750：角矩阵的数量|中等<br>中等|计数|||
|13|651：4键键盘<br>634：寻找数组的错误排列|中等<br>中等|计数|||
|14|1692：计算分配糖果的不同方式<br>418：屏幕可显示句子的数量|困难<br>中等|计数|||
|15|312：戳气球<br>1246：删除回文子数组|困难<br>困难|合并间隔|||
|16|40：组合总和2<br>983：最低票价|中等<br>中等|硬币兑换、组合求和|||
|17|1049：最后一块石头的重量<br>879：盈利计划|中等<br>困难|背包问题|||
|18|486：预测赢家<br>1406：石子游戏3|中等<br>困难|博弈论动态规划|||
|19|1510：石子游戏4<br>464：我能赢吗<br>1140：石子游戏3|困难<br>中等<br>中等|博弈论动态规划|||
|20|698：划分为k个相等的子集<br>1066：校园自行车分配|中等<br>中等|位运算|||
|21|902：最大为N的数字组合<br>600：不含连续1的非负整数|困难<br>困难|数字类DP|||

### 4.4 DP大师(大师就不做了，DP的题目到此告一段落)


## 5. 算法技巧

### 5.1  位操作
1. 有趣的几个操作
   1. ('A' | ' ' ) = a；('a' | ' ' ) = a
   2. ('B' & ' ' ) = b；('b' & ' ' ) = b
   3. ('B' ^ ' ' ) = b；('b' ^ ' ' ) = B
   4. 判断两个数是否是异号：(x^y)< 0: 是异号；(x^y) > 0:不是异号。利用了数字是补码表示的特点

2. 常用的几个操作
  1. n&(n-1): 消除数字n的二进制表示中的最后一个1
      * 可以用来求汉明距：一个数字n的二进制表示中有几个1
      * 判断一个数字是不是2的指数：一个数字n的二进制表示中不是只有一个1
  2. n^n = 0，n^0 = n：
     * 对于一个长度为2*n+1的数组，里面只有一个数是不重复的，找到它
     * 对于一个长度为n的数组，里面存储了[0,n]这n+1个数中的n个，找到漏掉的那个 (这个要配合索引)

### 5.2 两道数学阶乘题目

1. 172,n!的结果后面有几个0：
    * 考虑n\*(n-1)\*(n-2)\*...\*1，把这里面的数都进行因式分解
    * 可以得到m1个2和m2个5，显然m1>m2，当2*5才能出现10
    * 然后我们就看1~n里面可以提供多少个5
    * 所有5的倍数可以提供1个5==>1*5
    * 所有25的倍数可以提供2个5 ==> 5*5，。。。。
    * 但是25即是5的倍数，又是25的倍数，所以计算的时候，25里面的2个5拆成两部分，一个给5，一个给25
    * 那么问题变成 res = n//5 + n//25 + n//125 +...+...

2. 793，给一个k，问一共有多少个数的阶乘末尾有k个0
    * 从1遍历到2**63-1，看有几个数满足就行
    * 为了提升速度，使用二分查找法，分别查找前驱和后继即可

### 5.3 素数查找

常用的做法是使用for循环遍历，然后一个一个判断，这里有个筛选法比较高效：

```
# 常规写法
isPrime = [False,False]+[True]*n    # 假设所有的都是素数
for i in range(2,n):        # for循环每个数
    if isPrime[i]:              # 如果这个数是素数，那么它的倍数一定不是素数
        for j in range(2*i,n,i):
            isPrime[j] = False

# 改进写法
isPrime = [False,False]+[True]*n
for i in range(2,int(n**0.5)+1):
    if isPrime[i]:
        for j in range(i*i,n,i):
            isPrime[j] = False
```
### 5.4 重复或者缺失元素查找

有一个长度为n的数组a，查找里面缺失或者重复的元素，**关键在于元素和索引是成对出现的，常用的方法是排序、异或、映射**。
* 题目： 645，268

### 5.5 前缀和、差分
一般遇到**子数组，和**关键字的时候想到前缀和
`304和560可以练练`
* 一维前缀和：
  * 1. 将nums下标从 0,n ---> 1,n+1
  * 2. 初始化sums[0,n+1]
  * 3. 计算nums[left]+...+nums[right]: left-->left+1,right-->right+1, result = sums[right]-sums[left-1]
* 二维前缀和：
  * 1. 将nums下标从 0,n --> 1,n+1
  * 2. 初始化sums[0,n+1][0,n+1]
  * 3. sums[i][j] = sum[i-1][j] + sums[i][j-1] + sums[i-1][j-1] + nums[i][j]
  * 4. 计算左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素总和：
    * row1,col1,row2,col2 --> +1
    * sums[row2][col2] - sums[row2][col1-1] - sums[row1-1][col2]  + sums[row1-1][col1-1]

一般遇到频繁对**数组[i,j]区间进行统一加或者减操作**
* 差分
  * 初始化diff[0,n], diff[i] = nums[i]-diff[i-1] if i >= 1 else nums[0]
  * 计算nums[i] = nums[i-1]+diff[i] if i >= 1 else diff[0]
  * 对nums[i,....j] 都+k的操作：diff[i] += k,   diff[j+1] -= k    if  j+1<length


### 5.6 滑动窗口
滑动窗口的题目一般都是中等或者难题，对于滑动窗口，记住下面的操作步骤就行：
1. 更新右指针，直到窗口满足条件，此时更新全局结果
2. 更新左指针，直到窗口不满足条件
3. 重复1，2步骤直到无法满足1或者遍历完毕

```python
left = right = 0
n = len(s)
while right < n:
    add s[right] to window

    while valid(window):
        """这里更新全局变量"""
        
        remove s[left] from window
        left += 1

    right += 1

return 
```

### 5.7 常数从数组添加或删除元素
* hash + list，再用一个size记录长度
* 添加：添加到list末尾
* 删除list[i]: 交换list[i]和末尾元素，然后删除末尾元素


### 5.8 单调栈
`316,321,402,1081`
* 使用场景：**一个数组，找到每个数左边/右边第一个最大/最小的数**
* 变形场景：**对于一个数组，我们删除k个元素使剩下的元素满足某种条件**
* 算法：
  * 以找到左边第一个最小的数为例子：我们想找到左边第一个最小的数，那我们肯定想让栈顶元素最小
```python
nums = [xxx]
res = []
stack = collections.deque
for i,num in enumerate(nums):
    while stack and stack[nums[-1]] >= num:
        stack.pop()
    
    if stack.empty():
        res.append(-1)              # 第一个位置肯定是个特殊的符号
    else:
        res.append(stack[-1])
    stack.append(i)                 # 这里我们往栈里压index而不是具体数字，是为了便于扩展到不同题型
```
* 对于环形数组：直接把数组翻倍

### 5.9 单调队列
* 使用场景：**一个数组，找到窗口内的最大值或者最小值**
* 最大值：维护递减队列。最小值：维护递增队列。
* 和单调栈类似，遍历nums[i]的时候，当前的队头元素就是所求的值。

### 5.10 双指针
**双指针在list中的用法，都很常见了，这里主要将双指针在数组中的用法**
* 1. 求两数之和，三数，四数，k数之和target或者最接近的target的题目：
  * **先排序**，对于两数之和，左右两个指针left,right，分别向中间靠拢，if target > sum: right -= 1 else left += 1
  * **先排序**，对于三数之和，在两数之和前面套个for
  * **先排序**，对于四数之和，在三数之和前面套个for
  * ....
* 2. 有序数组去重: 直接从开头两个索引，left和right就行，left跑的慢，right跑的快



# 还没看的
* 贪心算法区间调度
* 贪心：安排会议室
* 贪心：视频拼接
* 贪心：跳跃游戏
* DP: LC 174，地下城游戏
* DP: LC 514，自由之路
* DP: 加权最短路径
* DP：正则表达式
* DP：高楼扔鸡蛋
* 二维数组的花式遍历技巧
* DP: 高楼扔鸡蛋进阶
* DP: 戳气球
* DP: 博弈问题
* DP: 四键键盘
* 前缀树
* 线段树
* 二分搜索

1. 我们要想得到最长单调子序列，那肯定希望每个子序列都缓慢增长
2. head[i]表示当前情况下长度为i的子系列的最后一个元素的最小值（假设i从1开始）
3. if num > head[-1]，说明我们可以在所有长度i的子序列上添加一个元素形成i+1长的子序列（说明head是单调递增的）
4. else, 说明我们没法添加，那就说明肯定可以拿它来更新长度为1,2,3,...,i的子序列的最后一个元素